#!/usr/bin/env node

const prettyjson = require('prettyjson');
const keycode = require('keycode');
const clicomp = require('clicomp');
const cliquest = require('../bin');

const Renderer = clicomp.Renderer;
const Pane = clicomp.Pane;
const Paragraph = clicomp.Paragraph;
const pwwBreak = clicomp.pwwBreak;
const escapes = clicomp.escapes;

const Cqf = cliquest.Cqf;
const Executor = cliquest.Executor;

const renderer = Renderer.instance;

const stdin = process.stdin;
const stdout = process.stdout;
stdin.setRawMode(true);
stdin.setEncoding('utf8');
stdin.resume();

const init = () => {
  renderer.clearScreen();
  renderer.cursorHide();

  const maxX = renderer.maxX();
  const maxY = renderer.maxY() - 1;
  const logsHeight = Math.ceil(maxY / 3) - 3;
  const contentHeight = maxY - logsHeight - 6;

  const pane = new Pane(0, 0, 999, contentHeight, 'project not loaded');
  pane.show();

  const paneP = new Paragraph(2, 1, '', {
    maxWidth: maxX - 8,
    maxHeight: contentHeight,
    wordWrap: pwwBreak,
    offset: 1
  });
  paneP.show();

  const logs = new Pane(0, contentHeight + 2, 999, logsHeight - 1, 'logs');
  logs.show();

  const logsP = new Paragraph(2, contentHeight + 3, '', {
    maxWidth: maxX - 8,
    maxHeight: logsHeight - 1,
    wordWrap: pwwBreak,
    offset: 1
  });
  logsP.show();

  const help = new Pane(0, maxY - 3, 999, 1, 'help');
  help.show();

  const helpP = new Paragraph(2, maxY - 1, '', {
    maxWidth: maxX - 8,
    maxHeight: 1,
    wordWrap: pwwBreak,
    offset: 1
  });
  helpP.show();

  return { pane, paneP, logsP, help, helpP };
};

const populateHelp = () => {
  helpP.text = [
    'l* load',
    'ctrl+p* scroll up',
    'strl+n* scroll down',
    'q* quit'
  ].join('; ');
};

const handleKeyboard = () => {
  help.label = 'help';
  helpP.text = ' '.repeat(helpP.text.length);
  helpP.text = '';

  populateHelp();

  const handler = (key) => {
    if (key == 'q') {
      process.exit();
    } else if (key == 'l') {
      stdin.removeListener('data', handler);
      handleLoad();
    } else if (keycode(key) == 16) {
      if (paneP.text.trim()) {
        let offset = paneP.options.offset;
        offset = offset > .25 ? (offset - .25) : 0;
        paneP.options.offset = offset;
        paneP.options = paneP.options;
        pane.scroll = paneP.options.offset;
      }
    } else if (keycode(key) == 14) {
      if (paneP.text.trim()) {
        let offset = paneP.options.offset;
        offset = offset < .75 ? (offset + .25) : 1;
        paneP.options.offset = offset;
        paneP.options = paneP.options;
        pane.scroll = paneP.options.offset;
      }
    }
  };
  stdin.on('data', handler);
};

const handleLoad = () => {
  help.label = 'load file...';
  helpP.text = ' '.repeat(helpP.text.length);
  helpP.text = '';

  let path = '';

  const handler = (key) => {
    if (key == '\u0003') {
      stdin.removeListener('data', handler);
      handleKeyboard();
    } else if (13 == keycode(key)) {
      loadFile(path);
      stdin.removeListener('data', handler);
      handleKeyboard();
    } else {
      if (keycode(key) === 127) {
        helpP.text = helpP.text.slice(0, -1);

        path = path.slice(0, -1);
      } else {
        helpP.text += key;

        path += key;
      }
    }
  };
  stdin.on('data', handler);
};

const loadFile = (path) => {
  paneP.options.offset = 1;
  paneP.options = paneP.options;
  logsP.text += `loading file ${path}...` + '\n';

  try {
    const chain = Cqf.parse(path, 'utf8');
    if (chain) {
      const executor = new Executor(chain);

      try {
        executor.process(0).then(response => {
          pane.label = `* ${path} *`;
          logsP.text += `loading complete` + '\n';

          if (true) {
            paneP.text += 'Variables:' + '\n';
            for (const variable of response.variables) {
              paneP.text += '  ' + `  ${variable.name} : ${variable.value}` + '\n';
            }
          } else {
            paneP.text += 'Variables:' + '\n';
            paneP.text += '  ' + prettyjson.render(response.variables) + '\n';
          }
          if (true) {
            paneP.text += 'Body:' + '\n';
            paneP.text += '  ' + prettyjson.render(response.data) + '\n';
          }
        }).catch(error => {
          pane.label = 'project not loaded';
          paneP.text = ' ';

          logsP.text += error + '\n';
        });
      } catch (e) {
        pane.label = 'project not loaded';
        paneP.text = ' ';

        logsP.text += e + '\n';
      }
    }
  } catch (e) {
    pane.label = 'project not loaded';
    paneP.text = ' ';

    logsP.text += e + '\n';
  }

  pane.scroll = paneP.options.offset;
};

const handleExit = () => {
  process.on('cleanup', () => {
    renderer.clearScreen();
    renderer.cursorShow();

    console.log('Have fun...');
  });

  process.on('exit', function () {
    process.emit('cleanup');
  });

  process.on('SIGINT', function () {
    console.log('Ctrl-C...');
    process.exit(2);
  });

  process.on('uncaughtException', function (e) {
    console.log('Uncaught Exception...');
    console.log(e.stack);
    process.exit(99);
  });
};

const { pane, paneP, logsP, help, helpP } = init();
handleKeyboard();
handleExit();
